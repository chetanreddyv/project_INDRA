"""
nodes/tools.py â€” Native LangGraph tool execution node.

Executes standard LangChain tool calls generated by the LLM and
appends the result as a ToolMessage to the state.
"""

import logging
from langchain_core.messages import ToolMessage

logger = logging.getLogger(__name__)

def _get_tool_registry() -> dict:
    try:
        from mcp_servers import GLOBAL_TOOL_REGISTRY
        return GLOBAL_TOOL_REGISTRY
    except ImportError as e:
        logger.warning(f"Could not load GLOBAL_TOOL_REGISTRY: {e}")
        return {}

import inspect

async def _execute_tool_func(action_name: str, tool_args: dict, config: dict) -> str:
    registry = _get_tool_registry()
    func = registry.get(action_name)
    if not func:
        return f"Error: Tool '{action_name}' not found in registry."
    
    try:
        logger.info(f"  -> Executing {action_name}({tool_args})")
        if hasattr(func, "ainvoke"):
            result = await func.ainvoke(tool_args, config=config)
        else:
            result = func(**tool_args)
            if inspect.isawaitable(result):
                result = await result
        logger.info(f"  -> {action_name} completed successfully")
        return str(result)
    except Exception as e:
        logger.error(f"  -> {action_name} failed: {e}")
        return f"Error executing {action_name}: {e}"

async def execute_tools_node(state: dict) -> dict:
    """
    Execute tool calls in the last AI message and append the results as ToolMessages.
    """
    logger.info("--- [Node: Execute Tools] ---")
    messages = state.get("messages", [])
    if not messages:
        return {}
    
    last_message = messages[-1]
    # Check if the last message has tool calls
    if not hasattr(last_message, "tool_calls") or not last_message.tool_calls:
        return {}
    
    tool_messages = []
    
    # Tools like exec_command and delegate_research need the thread_id to inject backgrounds
    thread_id = state.get("chat_id", "default_thread")
    config = {"configurable": {"thread_id": thread_id}}
    
    for tool_call in last_message.tool_calls:
        action_name = tool_call["name"]
        tool_args = tool_call["args"]
        call_id = tool_call["id"]
        
        result_str = await _execute_tool_func(action_name, tool_args, config)
        tool_messages.append(ToolMessage(content=result_str, tool_call_id=call_id))
        
    return {"messages": tool_messages}
